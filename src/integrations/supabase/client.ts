// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Get environment variables
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY;

// Enhanced environment variable validation
function validateEnvironmentVariables() {
  const requiredEnvVars = {
    'VITE_SUPABASE_URL': SUPABASE_URL,
    'VITE_SUPABASE_ANON_KEY': SUPABASE_PUBLISHABLE_KEY
  };

  const missingVars = Object.entries(requiredEnvVars)
    .filter(([_, value]) => !value)
    .map(([key]) => key);

  if (missingVars.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missingVars.join(', ')}. ` +
      'Please check your .env file and AWS Amplify environment variables.'
    );
  }

  // Validate URL format
  try {
    new URL(SUPABASE_URL);
  } catch {
    throw new Error('VITE_SUPABASE_URL is not a valid URL');
  }

  // Validate key format (basic check)
  if (!SUPABASE_PUBLISHABLE_KEY.match(/^[a-zA-Z0-9._-]+$/)) {
    throw new Error('VITE_SUPABASE_ANON_KEY has invalid format');
  }
}

// Validate environment variables
validateEnvironmentVariables();

// Enhanced Supabase client configuration
const supabaseConfig = {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    storageKey: 'sb-session-key', // Custom storage key
    storage: window.sessionStorage // Use sessionStorage for better security
  },
  global: {
    headers: { 
      'x-application-name': 'wedding-rsvp',
      'x-client-info': 'wedding-rsvp-web'
    }
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  }
};

// Rate limiting configuration
const RATE_LIMIT = {
  maxRequests: 50,
  windowMs: 60000, // 1 minute
  requests: new Map<string, number[]>()
};

// Rate limiting function
function checkRateLimit(operation: string): boolean {
  const now = Date.now();
  const windowStart = now - RATE_LIMIT.windowMs;
  
  // Get or initialize request timestamps for this operation
  let requests = RATE_LIMIT.requests.get(operation) || [];
  requests = requests.filter(timestamp => timestamp > windowStart);
  
  if (requests.length >= RATE_LIMIT.maxRequests) {
    console.warn(`Rate limit exceeded for operation: ${operation}`);
    return false;
  }
  
  requests.push(now);
  RATE_LIMIT.requests.set(operation, requests);
  return true;
}

// Cache for responses
const responseCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Export a function to transform database comments to the internal type
export const transformDatabaseComment = (dbComment: any) => {
  return {
    id: dbComment.id,
    name: dbComment.name,
    message: dbComment.message,
    date: new Date(dbComment.created_at),
    likes: dbComment.likes || 0,
    replies: []
  };
};

// Export a function to transform database replies to the internal type
export const transformDatabaseReply = (dbReply: any) => {
  return {
    id: dbReply.id,
    name: dbReply.name,
    message: dbReply.message,
    date: new Date(dbReply.created_at),
    likes: dbReply.likes || 0
  };
};

// Create Supabase client with enhanced configuration
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  supabaseConfig
);

// Enhanced retry mechanism with rate limiting
export const withRetry = async <T>(
  operation: string,
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> => {
  let retries = 0;
  
  while (retries < maxRetries) {
    if (!checkRateLimit(operation)) {
      throw new Error(`Rate limit exceeded for operation: ${operation}`);
    }
    
    try {
      return await fn();
    } catch (error: any) {
      retries++;
      
      if (retries === maxRetries) {
        console.error(`Operation failed after ${maxRetries} retries:`, error);
        throw error;
      }
      
      // Exponential backoff with jitter
      const delay = Math.min(1000 * Math.pow(2, retries) * (0.9 + Math.random() * 0.2), 10000);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw new Error('Unexpected error in retry mechanism');
};

// Export a secure version of the Supabase client that enforces rate limiting
export const secureSupabase = new Proxy(supabase, {
  get(target, prop) {
    const value = target[prop as keyof typeof target];
    if (typeof value === 'function') {
      return (...args: any[]) => {
        if (!checkRateLimit(prop.toString())) {
          throw new Error(`Rate limit exceeded for operation: ${prop.toString()}`);
        }
        return value.apply(target, args);
      };
    }
    return value;
  }
});

// Helper function to get cached data or fetch from Supabase
export const getCachedData = async (key: string, fetchFn: () => Promise<any>) => {
  const cached = responseCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  
  const data = await withRetry(key, fetchFn);
  responseCache.set(key, { data, timestamp: Date.now() });
  return data;
};
